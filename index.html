<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Exam Interface</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f9f9f9;
    }
    .exam-list {
      padding: 20px;
      text-align: center;
    }
    .exam-card {
      border: 1px solid #ddd;
      padding: 15px;
      margin: 10px auto;
      background-color: #fff;
      width: 300px;
    }
    /* Container for navigation pane + question area */
    .container {
      display: flex;
      padding: 20px;
    }
    /* Navigation pane styling */
    .nav-pane {
      width: 150px;
      margin-right: 20px;
    }
    .nav-pane ul {
      scroll-behavior: auto;
      list-style: none;
      padding: 0;
    }
    .nav-pane li {
      margin-bottom: 5px;
      padding: 5px;
      border: 1px solid #ccc;
      text-align: center;
      cursor: pointer;
    }
    .nav-not-attempted { background-color: grey; color: white; }
    .nav-attempted     { background-color: blue; color: white; }
    .nav-correct       { background-color: green; color: white; }
    .nav-wrong         { background-color: red; color: white; }
    .flag-icon {
      margin-left: 5px;
      color: orange;
    }
    /* Question container styling */
    .question-container {
      flex: 1;
      background-color: #fff;
      padding: 20px;
      border: 1px solid #ddd;
    }
    .timer {
      text-align: right;
      font-weight: bold;
      margin-bottom: 10px;
    }
    button {
      margin: 5px;
      padding: 8px 15px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #007bff;
      color: white;
    }
    button:hover {
      background-color: #0056b3;
    }
    .explanation {
      display: none;
      margin-top: 20px;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 5px;
    }
    /* Option buttons styling */
    #options-container button.correct { background-color: green; }
    #options-container button.wrong { background-color: red; }
  </style>
</head>
<body>
  <!-- Exam list (choose an exam) -->
  <div class="exam-list">
    <h2>Available Exams</h2>
    <div class="exam-card" data-exam-id="1">
      <h3>General Knowledge Exam</h3>
      <button onclick="startExam(1)">Start Exam</button>
    </div>
  </div>

  <!-- Main container: Navigation pane and Question container -->
  <div class="container" style="display: none;">
    <!-- Left navigation pane -->
    <div class="nav-pane">
      <ul id="question-nav"></ul>
    </div>

    <!-- Right question container -->
    <div class="question-container">
      <div class="timer">Time Left: <span id="time">60:00</span></div>
      <h2 id="question-text"></h2>
      <div id="options-container"></div>
      <div>
        <button id="flag-btn" onclick="toggleFlag()">Flag Question</button>
      </div>
      <button id="reveal-btn" style="display: none;">Reveal Answer</button>
      <div class="explanation" id="explanation"></div>
      <div>
        <button id="prev-btn" onclick="prevQuestion()" style="display: none;">Previous</button>
        <button id="next-btn" onclick="nextQuestion()" style="display: none;">Next</button>
      </div>
    </div>
  </div>

  <script>
    // Global backend URL variable
    const backend = "http://localhost:8000";

    // Global state variables
    let currentExam = null;
    let currentQuestionIndex = 0;
    let score = 0;
    let timeLeft = 60 * 60; // total exam time in seconds (adjust as needed)
    let timerInterval;
    let sessionId = null; // set after creating a session on the backend

    /* Object to hold individual question progress.
       Structure (keyed by question index):
       {
         answer: number|null,         // userâ€™s selected answer index
         timeTaken: number,           // seconds spent on this question
         flagged: boolean,            // whether the user flagged the question
         submitted: boolean,          // whether the answer was submitted (revealed)
         correct: boolean|null        // true if answer is correct, false if not (null if not submitted)
       }
    */
    let questionProgress = {};
    let questionStartTime = null;  // to track how long the user spends on each question

    // Try to restore progress from localStorage (if available)
    function restoreProgress() {
      const savedProgress = localStorage.getItem('questionProgress');
      const savedIndex = localStorage.getItem('currentQuestionIndex');
      const savedSession = localStorage.getItem('sessionId');
      const savedTime = localStorage.getItem('timeLeft');
      if (savedProgress) {
        questionProgress = JSON.parse(savedProgress);
      }
      if (savedIndex) {
        currentQuestionIndex = parseInt(savedIndex);
      }
      if (savedSession) {
        sessionId = savedSession;
      }
      if (savedTime) {
        timeLeft = parseInt(savedTime);
      }
    }

    // Save progress in localStorage and update backend session
    function saveProgress() {
      localStorage.setItem('questionProgress', JSON.stringify(questionProgress));
      localStorage.setItem('currentQuestionIndex', currentQuestionIndex);
      localStorage.setItem('sessionId', sessionId);
      localStorage.setItem('timeLeft', timeLeft);
      updateSessionOnBackend();
      updateNavPane();
    }

    // Update overall session progress on the backend (PUT /sessions/{session_id})
    function updateSessionOnBackend() {
      fetch(`${backend}/sessions/${sessionId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          current_question: currentQuestionIndex,
          score: score
        })
      })
      .then(response => {
        if (!response.ok) {
          console.error("Failed to update session on backend");
        }
      })
      .catch(error => console.error("Error updating session: ", error));
    }

    // Timer: update remaining time and check for timeout
    function startTimer(duration) {
      timeLeft = duration;
      timerInterval = setInterval(() => {
        timeLeft--;
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        document.getElementById('time').textContent =
          `${minutes}:${seconds.toString().padStart(2, '0')}`;
        if (timeLeft <= 0) endExam();
      }, 1000);
    }

    // Start exam: create a session and fetch exam questions.
    function startExam(examId) {
      document.querySelector('.exam-list').style.display = 'none';
      document.querySelector('.container').style.display = 'flex';
      restoreProgress();

      if (!sessionId) {
        // Create new session if none saved
        fetch(`${backend}/sessions/?current_user_id=1`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ exam_id: examId })
        })
        .then(response => {
          if (!response.ok) throw new Error("Session creation failed");
          return response.json();
        })
        .then(sessionData => {
          sessionId = sessionData.id;
          localStorage.setItem('sessionId', sessionId);
          return fetch(`${backend}/exams/${examId}/questions`);
        })
        .then(response => {
          if (!response.ok) throw new Error("Failed to fetch exam questions");
          return response.json();
        })
        .then(questionsData => {
          currentExam = {
            title: "Exam",
            total_time: questionsData.length * 60,  // e.g. 60 sec per question
            questions: questionsData
          };
          // Initialize progress for each question if not already present
          for (let i = 0; i < currentExam.questions.length; i++) {
            if (!questionProgress[i]) {
              questionProgress[i] = { answer: null, timeTaken: 0, flagged: false, submitted: false, correct: null };
            }
          }
          startTimer(currentExam.total_time);
          renderNavPane();
          showQuestion(currentQuestionIndex);
        })
        .catch(error => {
          console.error("Error starting exam: ", error);
          alert("Error starting exam. Please try again later.");
        });
      } else {
        // Restore an existing session and exam progress
        fetch(`${backend}/exams/${examId}/questions`)
        .then(response => {
          if (!response.ok) throw new Error("Failed to fetch exam questions");
          return response.json();
        })
        .then(questionsData => {
          currentExam = {
            title: "Exam",
            total_time: questionsData.length * 60,
            questions: questionsData
          };
          for (let i = 0; i < currentExam.questions.length; i++) {
            if (!questionProgress[i]) {
              questionProgress[i] = { answer: null, timeTaken: 0, flagged: false, submitted: false, correct: null };
            }
          }
          startTimer(timeLeft);
          renderNavPane();
          showQuestion(currentQuestionIndex);
        })
        .catch(error => {
          console.error("Error fetching exam questions: ", error);
        });
      }
    }

    // Render the navigation pane (list of question numbers)
    function renderNavPane() {
      const navUl = document.getElementById('question-nav');
      navUl.innerHTML = '';
      for (let i = 0; i < currentExam.questions.length; i++) {
        const li = document.createElement('li');
        li.textContent = i + 1;
        li.onclick = () => {
          currentQuestionIndex = i;
          showQuestion(i);
          saveProgress();
        };
        navUl.appendChild(li);
      }
      updateNavPane();
    }

    // Update the colors and flag icons in the navigation pane.
    function updateNavPane() {
      const navItems = document.querySelectorAll('#question-nav li');
      navItems.forEach((li, index) => {
        li.className = ''; // reset class
        const progress = questionProgress[index];
        if (!progress || progress.answer === null) {
          li.classList.add('nav-not-attempted');
        } else if (progress.submitted) {
          if (progress.correct) {
            li.classList.add('nav-correct');
          } else {
            li.classList.add('nav-wrong');
          }
        } else {
          li.classList.add('nav-attempted');
        }
        if (progress && progress.flagged && !li.innerHTML.includes('ðŸš©')) {
          li.innerHTML = li.textContent + ' <span class="flag-icon">ðŸš©</span>';
        } else {
          li.innerHTML = li.textContent;
        }
      });
    }

    // Show the current question and its options
    function showQuestion(index) {
      questionStartTime = Date.now();
      const question = currentExam.questions[index];
      document.getElementById('question-text').textContent = question.text;
      const optionsContainer = document.getElementById('options-container');
      optionsContainer.innerHTML = '';
      question.options.forEach((option, i) => {
        const btn = document.createElement('button');
        btn.textContent = option;
        btn.onclick = () => selectOption(i);
        optionsContainer.appendChild(btn);
      });
      document.getElementById('reveal-btn').style.display = 'none';
      document.getElementById('explanation').style.display = 'none';
      document.getElementById('prev-btn').style.display = (index > 0) ? 'block' : 'none';
      document.getElementById('next-btn').style.display = 'block';
    }

    // Record the answer when a user selects an option.
    function selectOption(selectedIndex) {
      const timeTaken = Math.floor((Date.now() - questionStartTime) / 1000);
      const progress = questionProgress[currentQuestionIndex];
      progress.answer = selectedIndex;
      progress.timeTaken = timeTaken;
      saveProgress();
      document.getElementById('reveal-btn').style.display = 'block';
      document.getElementById('reveal-btn').onclick = () => revealAnswer(selectedIndex);
    }

    // Reveal the answer, mark correct/wrong, and update progress.
    function revealAnswer(selectedIndex) {
      const question = currentExam.questions[currentQuestionIndex];
      const options = document.querySelectorAll('#options-container button');
      options.forEach((btn, i) => {
        btn.disabled = true;
        if (i === question.correct_answer) {
          btn.classList.add('correct');
        } else if (i === selectedIndex) {
          btn.classList.add('wrong');
        }
      });
      document.getElementById('explanation').style.display = 'block';
      document.getElementById('explanation').textContent = question.explanation;
      const progress = questionProgress[currentQuestionIndex];
      progress.submitted = true;
      progress.correct = (selectedIndex === question.correct_answer);
      if (progress.correct) score++;
      saveProgress();
      updateQuestionProgress(currentQuestionIndex, progress);
    }

    // Send an update to the backend for an individual questionâ€™s progress.
    function updateQuestionProgress(questionIndex, progress) {
      const questionId = currentExam.questions[questionIndex].id;
      fetch(`${backend}/sessions/${sessionId}/questions/${questionId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(progress)
      })
      .then(response => {
        if (!response.ok) {
          console.error("Failed to update question progress on backend");
        }
      })
      .catch(error => console.error("Error updating question progress: ", error));
    }

    // Toggle flag status for the current question.
    function toggleFlag() {
      const progress = questionProgress[currentQuestionIndex];
      progress.flagged = !progress.flagged;
      saveProgress();
      updateNavPane();
      updateQuestionProgress(currentQuestionIndex, progress);
    }

    // Navigation: next question
    function nextQuestion() {
      currentQuestionIndex++;
      if (currentQuestionIndex >= currentExam.questions.length) {
        endExam();
        return;
      }
      saveProgress();
      showQuestion(currentQuestionIndex);
    }

    // Navigation: previous question
    function prevQuestion() {
      if (currentQuestionIndex > 0) {
        currentQuestionIndex--;
        saveProgress();
        showQuestion(currentQuestionIndex);
      }
    }

    // End exam: stop timer, clear progress, and optionally mark session complete.
    function endExam() {
      clearInterval(timerInterval);
      alert(`Exam finished! Score: ${score} / ${currentExam.questions.length}`);
      localStorage.removeItem('questionProgress');
      localStorage.removeItem('currentQuestionIndex');
      localStorage.removeItem('sessionId');
      localStorage.removeItem('timeLeft');
      // Optionally, call a backend endpoint to complete the session.
      location.reload();
    }
  </script>
</body>
</html>
